#include "convert_ascii_to_ebcdic.h"

static char ebcdic_code[128] = {
  0,1,2,3,55,45,46,47,  22,5,37,11,12,13,14,15,
  16,17,1,19,60,61,0,38,  24,25,63,39,28,29,30,31,
  0x40,0x4f,0x7f,0x7b,0x5b,0x6c,0x50,0x7d,0x4d,0x5d,0x5c,0x4e,0x6b,0x60,0x4b,0x61,
  0xf0,0xf1,0xf2,0xf3,0xf4,0xf5,0xf6,0xf7,0xf8,0xf9,0x7a,0x5e,0x4c,0x7e,0x6e,0x6f,
  0x7c,0xc1,0xc2,0xc3,0xc4,0xc5,0xc6,0xc7,0xc8,0xc9,0xd1,0xd2,0xd3,0xd4,0xd5,0xd6,
  0xd7,0xd8,0xd9,0xe2,0xe3,0xe4,0xe5,0xe6,0xe7,0xe8,0xe9,0x4a,0xe0,0x5a,0x5f,0x6d,
  0x79,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x91,0x92,0x93,0x94,0x95,0x96,
  0x97,0x98,0x99,0xa2,0xa3,0xa4,0xa5,0xa6,0xa7,0xa8,0xa9,0xc0,0x6a,0xd0,0xa1,0x07
  
};

/* Takes an ASCII character and returns the EBCDIC equivalent. */
char ascii_to_ebcdic_c (char ascii) {
  return ebcdic_code[ascii];
}

/* Takes a null-terminated ASCII string and a pointer to a buffer large enough
 * to hold the EBCDIC equivalent, and fills the EBCIDC buffer with the correct
 * transcoding. The buffers may be the same, but if they overlap and don't
 * have the same start, strange things may happen.
 */
char* ascii_to_ebcdic (char* ascii, char* ebcdic) {
  char* retval = ebcdic;
  do {
    *ebcdic++=ascii_to_ebcdic_c(*ascii++);
  } while (*ascii);
  return retval;
}